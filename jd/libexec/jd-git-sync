#!/usr/bin/env bash
#
# Usage: jd git-sync
#
# Summary: Fetch and sync all git branches with their remote tracking branches

if [ "$1" = "--complete" ]; then
  echo "-q"
  exit
fi

# Defaults
quiet=

while [ $# -gt 0 ]; do
  case "$1" in
    -q|--quiet) quiet="--quiet" ;;
    (--) shift; break ;;
    (*) break ;;
  esac
  shift
done

git fetch $quiet --progress --all -Pp

defaultbranch="$(git config init.defaultbranch)"
defaultbranch="${defaultbranch:-main}"
currentbranch="$(git rev-parse --abbrev-ref HEAD)"

set -e

message() {
  if [[ -z "$quiet" ]]; then
    echo $@
  fi
}

git for-each-ref --format '%(refname:short):%(upstream:short)' 'refs/heads' | egrep -v ':$' | while IFS=: read local remote; do
  message "Syncing ${local} with ${remote}"

  fullbranch="refs/heads/${local}"
  fullremote="refs/remotes/${remote}"
  branchsha="$(git rev-parse -q $fullbranch)"
  remotesha="$(git rev-parse -q $fullremote)"

  if [[ -z "$remotesha" || "$branchsha" = "$remotesha" ]]; then
    message "${local} is up to date"
  elif (git merge-base --is-ancestor "$branchsha" "$remotesha" > /dev/null) ; then
    if [[ "$local" == "$currentbranch" ]]; then
      if [ -n "$(git status --porcelain | egrep -v '^\?\? ')" ]; then
        echo "ERROR: ${local} has files that are not checked in" >&2
      else
        git merge $quiet --ff-only "$remote"
      fi
    else
      git update-ref "$fullbranch" "$fullremote"
    fi
  else
    echo "WARN: ${local} has unpushed commits"
  fi
done
