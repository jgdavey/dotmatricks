#!/usr/bin/env ruby
# Usage: jd sync-repos [opts]
# Summary: Update all git repos under a directory

if ARGV[0] == "--complete"
  puts "-j"
  puts "-ffull"
  puts "-fdots"
  puts "--base-dir"
  exit 0
end

require 'pathname'
require 'stringio'
require 'open3'
require 'fileutils'
require 'thread'
require 'optparse'
require 'ostruct'

FORMATS = [:dots, :full]

OPTIONS = OpenStruct.new(jobs: 2, base_dir: ENV["SOURCE_DIR"], format: :dots)

OptionParser.new do |opts|
  opts.banner = "Usage: jd sync-repos [options]"

  opts.on("-jNUM", "--threads NUM", Integer, "Number of concurrent threads to use") do |j|
    OPTIONS.jobs = j or abort("choose a number of threads")
  end

  opts.on("-fFORMAT", "--format FORMAT", FORMATS, "Which output format to use (#{FORMATS.map(&:to_s).join(",")})") do |f|
    OPTIONS.format = f or abort("choose a number of threads")
  end

  opts.on("--base-dir DIR", String, "Alternate base directory") do |d|
    OPTIONS.base_dir = d
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

def find_dirs(base)
  path = Pathname(base)
  if path.exist?
    Dir.glob(path.join("*", ".git")).map { |p| Pathname(p).dirname }
  else
    []
  end
end

Result = Struct.new(:success?, :name, :message) do
end

class Repository
  def self.from_path(path)
    pn = Pathname(path)
    new(pn, pn.basename)
  end

  attr_reader :path, :name

  def initialize(path, name)
    @path = path
    @name = name
  end

  def path
    @path ||= BASE.join(repo)
  end

  def run(cmd, *args)
    out, err, status = Open3.capture3(cmd, *args, :chdir => path)
    if status.success?
      Result.new(true, name, out.to_s.chomp)
    else
      Result.new(false, name, err.to_s.chomp)
    end
  end

  def update!
    if OPTIONS.format == :dots
      run("jd-git-sync", "--quiet")
    else
      run("jd-git-sync")
    end
  end
end

work = Queue.new
done = Queue.new

n = OPTIONS[:jobs].times

find_dirs(OPTIONS.base_dir).each do |d|
  work << Repository.from_path(d)
end

n.each { work << :done }

workers = n.map do |i|
  Thread.new do
    loop do
      repo = work.pop
      break if repo == :done
      result = repo.update!
      done.push(result)
    end
  end
end

results = []

printer = Thread.new do
  loop do
    result = done.pop
    break if result == :done
    results.push(result)
    case OPTIONS.format
    when :dots
      print "."
    when :full
      puts "\n** #{result.name} **"
      puts result.message
    end
  end
end

workers.each(&:join)
done.push(:done)
printer.join

successes, failures = results.partition(&:success?)

puts "done\n\nSuccessfully updated #{successes.length} repositories"

successes.each do |s|
  unless s.message.empty?
    puts "[#{s.name}] #{s.message}"
  end
end

unless failures.empty?
  puts "\nThere were problems with the following repos:"
  failures.each do |f|
    puts "[#{f.name}] #{f.message}"
  end
  exit 1
end
